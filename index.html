<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Tupelo by vjoel</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/vjoel/tupelo">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/vjoel/tupelo/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/vjoel/tupelo/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Tupelo</h1>
          <p>A language-agnostic tuplespace for distribution of computation and storage.</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/vjoel">vjoel</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a name="tupelo" class="anchor" href="#tupelo"><span class="octicon octicon-link"></span></a>Tupelo</h1>

<p>Tupelo is a language-agnostic tuplespace for coordination of distributed programs. It is designed for distribution of both computation and storage, on disk and in memory, with pluggable storage adapters. Its programming model is small and semantically transparent: there are tuples (built from arrays, hashes, and scalars), a few operations on tuples (read, write, take), and transactions composed of these operations. This data-centric model, unlike RPC and most forms of messaging, decouples application endpoints from each other, not only in space and time, but also in referential structure: processes refer to data rather than to other processes.</p>

<p>Tupelo is inspired by Masatoshi Seki's Rinda in the Ruby standard library, which in turn is based on David Gelernter's Linda. The programming models of Tupelo and Rinda are similar, except for the lack of transactions in Rinda. However, the implementations of the two are nearly opposite in architectural approach.</p>

<p>This repository contains the reference implementation in Ruby, with documentation, tests, benchmarks, and examples. Implementations in other languages must communicate with this one.</p>

<h1>
<a name="documentation" class="anchor" href="#documentation"><span class="octicon octicon-link"></span></a>Documentation</h1>

<h2>
<a name="introductory" class="anchor" href="#introductory"><span class="octicon octicon-link"></span></a>Introductory</h2>

<ul>
<li><a href="doc/tutorial.md">Tutorial</a></li>
<li><a href="example">Examples</a></li>
<li><a href="doc/faq.md">FAQ</a></li>
</ul><h2>
<a name="in-depth" class="anchor" href="#in-depth"><span class="octicon octicon-link"></span></a>In Depth</h2>

<ul>
<li><a href="doc/transactions.md">Transactions</a></li>
<li><a href="doc/replication.md">Replication</a></li>
<li><a href="doc/subspace.md">Subspaces</a></li>
<li><a href="doc/tuplestores.md">Tuple stores</a></li>
<li><a href="doc/causality.md">Causality</a></li>
<li><a href="doc/concurrency.md">Concurrency</a></li>
</ul><h2>
<a name="big-picture" class="anchor" href="#big-picture"><span class="octicon octicon-link"></span></a>Big Picture</h2>

<ul>
<li><a href="doc/compare.md">Comparisons</a></li>
<li><a href="doc/future.md">Planned future work</a></li>
</ul><h2>
<a name="internals" class="anchor" href="#internals"><span class="octicon octicon-link"></span></a>Internals</h2>

<ul>
<li><a href="doc/arch.md">Architecture</a></li>
<li><a href="doc/protocol.md">Protocols</a></li>
</ul><h2>
<a name="talk" class="anchor" href="#talk"><span class="octicon octicon-link"></span></a>Talk</h2>

<ul>
<li>
<a href="sfdc.md">Abstract</a> and <a href="doc/sfdc.pdf">slides</a> for San Francisco Distributed Computing meetup, December 2013.</li>
</ul><h1>
<a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting started</h1>

<ol>
<li><p>Install ruby 2.0 or 2.1 (not 1.9) from <a href="http://ruby-lang.org">http://ruby-lang.org</a>. Examples and tests will not work on Windows (they use fork and unix sockets) or JRuby, though probably the underying libs will (using tcp sockets on Windows).</p></li>
<li>
<p>Install the gem and its dependencies (you may need to <code>sudo</code> this):</p>

<pre><code>gem install tupelo
</code></pre>
</li>
<li>
<p>Try running tup:</p>

<pre><code>$ tup
&gt;&gt; w ["hello", "world"]
&gt;&gt; ra
=&gt; [["hello", "world"]]
&gt;&gt; t [nil, nil]
=&gt; ["hello", "world"]
</code></pre>
</li>
<li><p>Take a look at the <a href="doc/faq.md">FAQ</a>, the <a href="doc/tutorial.md">tutorial</a>, and the many <a href="example">examples</a>.</p></li>
</ol><h1>
<a name="applications" class="anchor" href="#applications"><span class="octicon octicon-link"></span></a>Applications</h1>

<p>Tupelo is a flexible base layer for various distributed programming patterns and techniques, which are explored in the examples: job queues, shared configuration and state, load balancing, service discovery, in-memory data grids, message queues, publish/subscribe, dataflow, map-reduce, and both optimistic and pessimistic (lock/lease) concurrency control.</p>

<p>Tupelo can be used to impose a unified transactional structure and distributed access model on a mixture of programs and languages (polyglot computation) and a mixture of data stores (polyglot persistence), with consistent replication.</p>

<p>See the <a href="#examples">example section</a> below and the <a href="example">examples</a> directory.</p>

<h1>
<a name="limitations" class="anchor" href="#limitations"><span class="octicon octicon-link"></span></a>Limitations</h1>

<h2>
<a name="bottleneck" class="anchor" href="#bottleneck"><span class="octicon octicon-link"></span></a>Bottleneck</h2>

<p>The main limitation of tupelo is that, except for read-only operations, <strong>all tuple operations pass through a single process</strong>, the message sequencer.</p>

<p>The sequencer has minimal state and minimal computation. The state is just a counter and the network connections (no storage of tuples or other application data). The computation is just counter increment and message dispatch (no transaction execution or searches). A transaction requires just one message (possibly with many recipients) to pass through the sequencer. The message sequencer can be light and fast.</p>

<p>Nevertheless, this process is a bottleneck. Each message traverses two hops, to and from the sequencer. Each tupelo client must be connected to the sequencer to transact on tuples (aside from local reads).</p>

<p><strong>Tupelo will always have this limitation.</strong> It is essential to the design of the system. By accepting this cost, we get some benefits, discussed in the next section.</p>

<p>Clients may communicate other data over side channels that do not go through the sequencer. For <a href="example/socket-broker.rb">example</a>, they can use the tuplespace to coordinate task assignments, data locations (perhaps external to the tuplespace), TCP hosts and ports, and other metadata, and then use direct connections for the data. The archiver, which is a special client that brings newly connected clients up to date, is another example of direct client-to-client connections.</p>

<h2>
<a name="other-limitations" class="anchor" href="#other-limitations"><span class="octicon octicon-link"></span></a>Other limitations</h2>

<p>The message sequencer is also a SPoF (single point of failure), but this is not inherent in the design. A future version of tupelo will have options for failover or clustering of the sequencer, perhaps based on <a href="http://raftconsensus.github.io">raft</a>, with a cost of increased latency and complexity. (However, redundancy and failover of <em>application</em> data and computation <em>is</em> supported by the current implementation; app data and computations are distributed among the client processes.)</p>

<p>There are some limitations that may result from naive application of tupelo: high client memory use, high bandwidth use, high client cpu use. These resource issues can often be controlled with <a href="doc/subspace.md">subspaces</a> and specialized data structures and data stores. There are several examples addressing these problems. Another approach is to use the tuplespace for low volume references to high volume data.</p>

<p>Also, see the discussion in <a href="doc/transactions.md">transactions</a> on limitations of transactions across subspaces. It's likely that these limitations will soon be lifted, at the cost of increased latency (only for cross-subspace transactions).</p>

<p>This implementation is also limited in efficiency because of its use of Ruby.</p>

<p>Finally, it must be understood that work on tupelo is still in early, experimental stages. <strong>The tupelo software should not yet be relied on for applications where failure resistance and recovery are important.</strong> The current version is suited for things like batch processing (especially complex dataflow topologies), which can be restarted after failure, or other distributed systems that have short lifespans or are disposable.</p>

<h1>
<a name="benefits" class="anchor" href="#benefits"><span class="octicon octicon-link"></span></a>Benefits</h1>

<p>As noted above, the sequencer assigns an incrementing sequence number, or <em>tick</em>, to each transaction and dispatches it to the clients, who take on all the burden of tuple computation and storage. This design choice leads to:</p>

<ul>
<li><p>strong consistency: all clients have the same view of the tuplespace at a given tick of the global clock;</p></li>
<li><p>deterministic transaction execution across processes: transactions complete in two network hops, and transactions reference concrete tuples, not templates or queries that require further searching;</p></li>
<li><p>high concurrency: no interprocess locking or coordination is needed to prepare or execute transactions;</p></li>
<li><p>efficient distribution of transaction workload off of the critical path: transaction preparation (finding matching tuples) is performed by just the client initiating the transaction, and transaction execution is performed only by clients that subscribe to subspaces relevant to the transaction;</p></li>
<li><p>client-side logic within transactions: any client state can be accessed while preparing a transaction, and each client is free to use any template and search mechanism (deterministic or not), possibly taking advantage of the client's specialized tuple storage;</p></li>
<li><p>zero-latency reads: clients store subscribed tuples locally, so searching and waiting for matching tuples are local operations;</p></li>
<li><p>relatively easy data replication: all subscribers to a subspace replicate that subspace, possibly with different storage implementations;</p></li>
<li><p>even though storage is distributed, the client programming model is that all tuples are in the same place at the same time; there is no need to reason about multiple clocks or clock skew;</p></li>
<li><p>the current state of the tuplespace can be computed from an earlier state by replaying the transactions in sequence;</p></li>
<li><p>the evolution of system state over time is observable, and tupelo provides the tools to do so: the <code>--trace</code> switch, the <code>#trace</code> api, and the <code>tspy</code> program.</p></li>
</ul><p>Additional benefits (not related to message sequencing) include:</p>

<ul>
<li><p>the <code>tup</code> program for interactively starting and connecting to tupelo instances;</p></li>
<li><p>a framework for starting and controlling child and remote processes connected to the tuplespace;</p></li>
<li><p>options to tunnel connections over ssh and through firewalls, for running in public clouds and other insecure environments;</p></li>
<li><p>choice of object serialization method (msgpack, json, marshal, yaml);</p></li>
<li><p>choice of UNIX or TCP sockets.</p></li>
</ul><p>Process control and tunneling are available independently of tupelo using the easy-serve gem.</p>

<h1>
<a name="examples" class="anchor" href="#examples"><span class="octicon octicon-link"></span></a>Examples</h1>

<h2>
<a name="distributed-processing" class="anchor" href="#distributed-processing"><span class="octicon octicon-link"></span></a>Distributed processing</h2>

<p>This program counts prime numbers in an interval by distributing the problem to a set of hosts:</p>

<pre><code>require 'tupelo/app/remote'

hosts = %w{itchy scratchy lisa bart} # ssh hosts with key-based auth

Tupelo.tcp_application do
  hosts.each do |host|
    remote host: host, passive: true, eval: %{
      require 'prime' # ruby stdlib for prime factorization
      loop do
        _, input = take(["input", Integer])
        write ["output", input, input.prime_division]
      end
    }
  end

  local do
    inputs = 1_000_000_000_000 .. 1_000_000_000_200

    inputs.each do |input|
      write ["input", input]
    end

    count = 0
    inputs.size.times do |i|
      _, input, factors = take ["output", Integer, nil]
      count += 1 if factors.size == 1 and factors[0][1] == 1
      print "\rChecked #{i}"
    end

    puts "\nThere are #{count} primes in #{inputs}"
  end
end
</code></pre>

<p>Ssh is used to set up the remote processes. Additionally, with the <code>--tunnel</code> command line argument, all tuple communication is tunneled over ssh. More examples like this are in <a href="example/map-reduce">example/map-reduce</a>, <a href="example/pregel">example/pregel</a>, and <a href="example/parallel.rb">example/parallel.rb</a>.</p>

<h2>
<a name="distributed-storage" class="anchor" href="#distributed-storage"><span class="octicon octicon-link"></span></a>Distributed storage</h2>

<p>Here's an example that creates an in-memory sqlite in one client with a table for Points of Interest (POI). A second client populates that table by writing POI tuples and then executes a SQL delete by writing a tuple with the deletion parameters.</p>

<pre><code>require 'tupelo/app'
require_relative 'poi-client' # run this in example/sqlite

Tupelo.application do
  local do
    POISPACE = PoiStore.define_poispace(self)
    define_subspace("cmd", {id: nil, cmd: String, arg: nil})
    define_subspace("rsp", {id: nil, result: nil})
  end

  child PoiClient, poispace: POISPACE, subscribe: "cmd", passive: true do
    loop do
      req = take subspace("cmd")
      case req[:cmd]
      when "delete box"
        lat = req[:arg][:lat]; lng = req[:arg][:lng]
        template = PoiTemplate.new(poi_template: subspace("poi"),
          lat: lat[0]..lat[1], lng: lng[0]..lng[1])
        deleted = []
        transaction do
          while poi = take_nowait(template)
            deleted &lt;&lt; poi
          end
        end
        write id: req[:id], result: deleted
      end
    end
  end

  child subscribe: "rsp" do
    write lat: 1.2, lng: 3.4, desc: "foo"
    write lat: 5.6, lng: 7.8, desc: "bar"
    write lat: 1.3, lng: 3.5, desc: "baz"

    write id: 1, cmd: "delete box", arg: {lat: [1.0, 1.4], lng: [3.0, 4.0]}
    rsp = take id: 1, result: nil
    log "deleted: #{rsp["result"]}"
  end
end
</code></pre>

<p>The output should be something like this:</p>

<pre><code>A: client 3: deleted: [{"lat"=&gt;1.2, "lng"=&gt;3.4, "desc"=&gt;"foo"}, {"lat"=&gt;1.3, "lng"=&gt;3.5, "desc"=&gt;"baz"}]
</code></pre>

<p>See <a href="example/sqlite">example/sqlite</a> for the complete example. More advanced versions of this example have remote, replicated sqlites for redundancy and load distribution.</p>

<h2>
<a name="web-app-coordination" class="anchor" href="#web-app-coordination"><span class="octicon octicon-link"></span></a>Web app coordination</h2>

<p>This example runs several sinatra web apps and uses tupelo to set up a chat network between their users.</p>

<pre><code>require 'tupelo/app'
require 'sinatra/base'

Tupelo.application do
  [9001, 9002, 9003].each do |port|
    child do |client|
      Class.new(Sinatra::Base).class_eval do
        post '/send' do
          client.write ["message", params["dest"], params["text"]]
        end

        get '/recv' do
          "%s for %s: %s\n" %
            (client.take ["message", params["dest"], String])
        end

        set :port, port
        run!
      end
    end
  end
end
</code></pre>

<p>You can use curl to chat:</p>

<pre><code>$ curl 'localhost:9001/send?text=hello&amp;dest=fred' -d ''
</code></pre>

<p>and</p>

<pre><code>$ curl 'localhost:9003/recv?dest=fred'
message for fred: hello
</code></pre>

<p>Note that the <code>recv</code> call waits for a message if none is available.</p>

<p>See also <a href="example/multi-tier">example/multi-tier</a> and the chat server in <a href="example/chat">example/chat</a>.</p>

<h1>
<a name="development" class="anchor" href="#development"><span class="octicon octicon-link"></span></a>Development</h1>

<p>Patches and bug reports are most welcome.</p>

<p>This project is hosted at <a href="https://github.com/vjoel/tupelo">https://github.com/vjoel/tupelo</a></p>

<h2>
<a name="dependencies" class="anchor" href="#dependencies"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>Gems that were developed to support this project:</p>

<ul>
<li><p><a href="https://github.com/vjoel/atdo">https://github.com/vjoel/atdo</a></p></li>
<li><p><a href="https://github.com/vjoel/easy-serve">https://github.com/vjoel/easy-serve</a></p></li>
<li><p><a href="https://github.com/vjoel/funl">https://github.com/vjoel/funl</a></p></li>
<li><p><a href="https://github.com/vjoel/object-stream">https://github.com/vjoel/object-stream</a></p></li>
<li><p><a href="https://github.com/vjoel/object-template">https://github.com/vjoel/object-template</a></p></li>
</ul><p>Other gems:</p>

<ul>
<li><p>msgpack</p></li>
<li><p>yajl-ruby (only used to support --json option)</p></li>
<li><p>nio4r (optional dependency of funl)</p></li>
</ul><p>Optional gems for some of the examples:</p>

<ul>
<li>sinatra, json, http, sequel, sqlite, rbtree, leveldb-native, lmdb</li>
</ul><h1>
<a name="contact" class="anchor" href="#contact"><span class="octicon octicon-link"></span></a>Contact</h1>

<p>Joel VanderWerf, <a href="mailto:vjoel@users.sourceforge.net">vjoel@users.sourceforge.net</a>, <a href="https://twitter.com/JoelVanderWerf">@JoelVanderWerf</a>.</p>

<h1>
<a name="license-and-copyright" class="anchor" href="#license-and-copyright"><span class="octicon octicon-link"></span></a>License and Copyright</h1>

<p>Copyright (c) 2013-2014, Joel VanderWerf</p>

<p>License for this project is BSD. See the COPYING file for the standard BSD license. The supporting gems developed for this project are similarly licensed.</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>