{"name":"Tupelo","tagline":"A tuplespace that is fast, scalable, and language agnostic.","body":"tupelo\r\n==\r\n\r\nA tuplespace that is fast, scalable, and language agnostic. It is designed for distribution of both computation and storage, in a unified language that has both transactional and tuple-operation (read/write/take) semantics.\r\n\r\n\r\nThis is the reference implementation in ruby. It should be able to communicate with implementations in other languages. Planned implementation languages include C, Python, and Go.\r\n\r\nTupelo differs from other spaces in several ways:\r\n\r\n* minimal central storage: the only state in the server is a counter and socket connections\r\n\r\n* minimal central computation: just counter increment, message dispatch, and connection management (and it never unpacks serialized tuples)\r\n\r\n* clients do all the tuple work: registering and checking waiters, matching, searching, notifying, storing, inserting, deleting, persisting, etc. Each client is free to to decide how to do these things (application code is insulated from this, however). Special-purpose clients (known as *tuplets*) may use specialized algorithms and stores for the subspaces they manage.\r\n\r\n* transactions, in addition to the classic operators (and transactions execute client-side, reducing bottleneck and increasing expressiveness).\r\n\r\n* replication is inherent in the design (in fact it is unavoidable), for better or worse.\r\n\r\nDocumentation\r\n============\r\n\r\n* [FAQ](doc/faq.md)\r\n* [Subspaces](doc/subspace.md)\r\n\r\nGetting started\r\n==========\r\n\r\n1. Install ruby 2 (not 1.9) from http://ruby-lang.org. Examples and tests will not work on windows (they use fork and unix sockets) or jruby, though probably the underying libs will (using tcp sockets).\r\n\r\n2. Install the gem and its dependencies (you may need to `sudo` this):\r\n\r\n        gem install tupelo\r\n\r\n3. Try running tup:\r\n\r\n        $ tup\r\n        >> w [\"hello\", \"world\"]\r\n        >> ra\r\n        => [[\"hello\", \"world\"]]\r\n        >> t [nil, nil]\r\n        => [\"hello\", \"world\"]\r\n\r\n  If you run tup with the --info switch it will tell you the aliases to the tuple API (and also tell you much about what is happening in your transactions). Here's an overview of the API, including the short aliases avilable in tup:\r\n\r\n  Write one or more tuples (and wait for the transaction to be recorded in the local space):\r\n\r\n        w <tuple>,...\r\n        write_wait <tuple>,...\r\n\r\n  Write without waiting:\r\n\r\n        write <tuple>,...\r\n\r\n  Write and then wait, under user control:\r\n\r\n        write(...).wait\r\n\r\n  Pulse a tuple or several (write but immediately delete it, like pubsub):\r\n\r\n        pl <tuple>,...\r\n        pulse_wait ...\r\n\r\n  Pulse without waiting:\r\n\r\n        pulse_nowait <tuple>,...\r\n\r\n  Read tuple matching a template, waiting for a match to exist:\r\n\r\n        r <template>\r\n        read <template>\r\n        read_wait <template>\r\n\r\n  Read tuple matching a template and return it, without waiting for a match to exist (returning nil in that case):\r\n\r\n        read_nowait <template>\r\n\r\n  Note that neither #read nor #read_nowait wait for any previously issued writes to complete. The difference is that #read waits for a match to exist and #read_nowait does not. Compare:\r\n  \r\n        write [1]; read_nowait [1]        # ==> nil, probably\r\n        write [2]; read [2]               # ==> [2]\r\n\r\n  Read all tuples matching a template, no waiting (like #read_nowait):\r\n\r\n        ra <template>\r\n        read_all <template>\r\n\r\n  If the template is omitted, reads everything (careful, you get what you ask for!). The template can be a standard template as discussed below or anything with a #=== method. Hence\r\n\r\n        ra Hash\r\n\r\n  reads all hash tuples (and ignores array tuples), and\r\n\r\n        ra proc {|t| t.size==2}\r\n\r\n  reads all 2-tuples.\r\n\r\n  Read tuples in a stream, both existing and as they arrive:\r\n\r\n        read <template> do |tuple| ... end\r\n        read do |tuple| ... end             # match any tuple\r\n\r\n  Take a tuple matching a template:\r\n\r\n        t <template>\r\n        take <template>\r\n\r\n  Take a tuple matching a template and optimistically use the local value before the transaction is complete:\r\n\r\n        x_final = take <template> do |x_optimistic|\r\n          ...\r\n        end\r\n\r\n  There is no guarantee that `x_final == x_optimistic`. The block may execute more than once.\r\n\r\n  Take a tuple matching a template, but only if a local match exists (otherwise return nil):\r\n\r\n        take_nowait <template>\r\n\r\n        x_final = take_nowait <template> do |x_optimistic|\r\n          ...\r\n        end\r\n\r\n  Note that a local match is still not a guarantee of `x_final == x_optimistic`. Another process may take `x_optimistic` first, and the take will be re-executed. (Think of #take_nowait as a way of saying \"take a match, but don't bother trying if there is no match known at this time.\") Similarly, #take_nowait returning nil is not a guarantee that a match does not exist: another process could have written a match later than the time of the local search.\r\n\r\n  Perform a general transaction:\r\n\r\n        result =\r\n          transaction do |t|\r\n            rval = t.read ... # optimistic value\r\n            t.write ...\r\n            t.pulse ...\r\n            tval = t.take ... # optimistic value\r\n            [rval, tval]      # pass out result\r\n          end\r\n\r\n  Note that the block may execute more than once, if there is competition for the tuples that you are trying to #take or #read. When the block exits, however, the transaction is final and universally accepted by all clients.\r\n\r\n  Tuples written or taken during a transaction affect subsequent operations in the transaction without modifying the tuplespace or affecting other concurrent transactions (until the transaction completes):\r\n  \r\n        transaction do |t|\r\n          t.write [3]\r\n          p t.read [3] # => 3\r\n          p read_all   # => [] # note read_all called on client, not trans.\r\n          t.take [3]\r\n          p t.read_nowait [3] # => nil\r\n        end\r\n\r\n  Be careful about context within the do...end. If you omit the `|t|` block argument, then all operations are automatically scoped to the transaction, rather than the client. The following is equivalent to the previous example:\r\n  \r\n        client = self # local var that we can use inside the block\r\n        transaction do\r\n          write [3]\r\n          p read [3]\r\n          p client.read_all\r\n          take [3]\r\n          p read_nowait [3]\r\n        end\r\n\r\n  You can timeout a transaction:\r\n  \r\n        transaction timeout: 1 do\r\n          read [\"does not exist\"]\r\n        end\r\n\r\n  This uses tupelo's internal lightweight scheduler, rather than ruby's heavyweight (one thread per timeout) Timeout, though the latter works with tupelo as well.\r\n  \r\n  You can also abort a transaction while inside it by calling `#abort` on it:\r\n\r\n        write [1]\r\n        transaction {take [1]; abort}\r\n        read_all # => [[1]]\r\n\r\n  Another thread can abort a transaction in progress (to the extent possible) by calling `#cancel` on it. See [example/cancel.rb](example/cancel.rb).\r\n\r\n4. Run tup with a server file so that two sessions can interact. Do this in two terminals in the same dir:\r\n\r\n        $ tup svr\r\n\r\n  (The 'svr' argument names a file that the first instance of tup uses to store information like socket addresses and the second instance uses to connect. The first instance starts the servers as child processes. However, both instances appear in the terminal as interactive shells.)\r\n  \r\n  To do this on two hosts, copy the svr file and edit its hostname params as needed.\r\n\r\n5. Look at the examples. You may need to dig a bit to find the gem installation. For example:\r\n\r\n        ls -d /usr/local/lib/ruby/gems/*/gems/tupelo*\r\n\r\n  Note that all bin and example programs accept blob type (e.g., --msgpack, --json) on command line (it only needs to be specified for server -- the clients discover it). Also, all these programs accept log level on command line. The default is --warn. The --info level is a good way to get an idea of what is happening, without the verbosity of --debug.\r\n\r\n6. Debugging: in addition to the --info switch on all bin and example programs, bin/tspy is also really useful; it shows all tuplespace events in sequence that they occur. For example, run\r\n\r\n        $ tspy svr\r\n\r\n  in another terminal after running `tup svr`. The output shows the clock tick, sending client, operation, and operation status (success or failure).\r\n\r\n  There is also the similar --trace switch that is available to all bin and example programs. This turns on diagnostic output for each transaction. For example:\r\n\r\n  ```\r\n    tick    cid status operation\r\n       1      2        batch write [\"x\", 1]\r\n       2      2        batch write [\"y\", 2]\r\n       3      3        atomic take [\"x\", 1], [\"y\", 2]\r\n  ```\r\n\r\n  The `Tupelo.application` command, provided by `tupelo/app`, is the source of all these options and is available to your programs. It's a kind of lightweight process deployment and control framework; however `Tupelo.application` is not necessary to use tupelo.\r\n\r\n\r\nWhat is a tuplespace?\r\n=====================\r\n\r\nA tuplespace is a service for coordination, configuration, and control of concurrent and distributed systems. The model it provides to processes is a shared space that they can use to communicate in a deterministic and sequential manner. (Deterministic in that all clients see the same, consistent view of the data.) The space contains tuples. The operations on the space are few, but powerful. It's not a database, but it might be a front-end for one or more databases.\r\n\r\nSee https://en.wikipedia.org/wiki/Tuple_space for general information and history. This project is strongly influenced by Masatoshi Seki's Rinda implementation, part of the Ruby standard library. See http://pragprog.com/book/sidruby/the-druby-book for a good introduction to rinda and druby.\r\n\r\nSee http://dbmsmusings.blogspot.com/2010/08/problems-with-acid-and-how-to-fix-them.html for an explanation of the importance of determinism in distributed transaction systems.\r\n\r\nWhat is a tuple?\r\n----------------\r\n\r\nA tuple is the unit of information in a tuplespace. It is immutable in the context of the tuplespace -- you can write a tuple into the space and you can read or take one from the space, but you cannot update a tuple within a space. A tuple does not have an identity other than the data it contains. A tuplespace can contain multiple copies of the same tuple. (In the ruby client, two tuples are considered the same when they are #==.)\r\n\r\nA tuple is either an array:\r\n\r\n    [\"hello\", 7]\r\n    [nil, true, false]\r\n    [\"foo\", 3.2, [6,5,4], {\"bar\" => 3}]\r\n\r\n... or a hash:\r\n \r\n    {name: \"Myrtle\", location: [100,200]}\r\n    { [1,2] => 3, [5,7] => 12 }\r\n\r\nIn other words, a tuple is a fairly general object, though this depends on the serializer--see below. More or less, a tuple is anything that can be built out of:\r\n\r\n* strings\r\n\r\n* numbers\r\n\r\n* nil, true, false\r\n\r\n* arrays\r\n\r\n* hashes\r\n\r\nIt's kind of like a \"JSON object\", except that, when using the json serializer, the hash keys can only be strings. In the msgpack case, keys have no special limitations. In the case of the marshal and yaml modes, tuples can contain many other kinds of objects.\r\n\r\nThe empty tuples `[]` and `{}` are allowed, but bare values such as `3.14` or `false` are not tuples by themselves.\r\n\r\nOne other thing to keep in mind: in the array case, the order of the elements is significant. In the hash case, the order is not significant. So these are both true:\r\n\r\n    [1,2] != [2,1]\r\n    {a:1, b:2} == {b:2, a:1}\r\n\r\n\r\nWhat is a template?\r\n-------------------\r\n\r\nA template an object that matches (or does not match) tuples. It's used for querying a tuplespace. Typically, a template looks just like a tuple, but possibly with wildcards of some sort. The template:\r\n\r\n    [3..5, Integer, /foo/, nil]\r\n\r\nwould match the tuple:\r\n\r\n    [4, 7, \"foobar\", \"xyz\"]\r\n\r\nbut not these tuples:\r\n\r\n    [6, 7, \"foobar\", \"xyz\"]\r\n    [3, 7.2, \"foobar\", \"xyz\"]\r\n    [3, 7, \"fobar\", \"xyz\"]\r\n\r\nThe nil wildcard matches anything. The Range, Regexp, and Class entries function as wildcards because of the way they define the #=== (match) method. See ruby docs for general information on \"threequals\" matching.\r\n\r\nEvery tuple can also be used as a template. The template:\r\n\r\n    [4, 7, \"foobar\", \"xyz\"]\r\n\r\nmatches itself.\r\n\r\nHere's a template for matching some hash tuples:\r\n\r\n    {name: String, location: \"home\"}\r\n\r\nThis would match all tuples whose keys are \"name\" and \"location\" and whose values for those keys are any string and the string \"home\", respectively.\r\n\r\nA template doesn't have to be a tuple pattern with wildcards, though. It can be anything with a #=== method. For example:\r\n \r\n    read_all proc {|t| some_predicate(t)}\r\n    read_all Hash\r\n    read_all Array\r\n    read_all Object\r\n\r\nAn optional library, `tupelo/util/boolean`, provides a #match_any method to construct the boolean `or` of other templates:\r\n\r\n    read_all match_any( [1,2,3], {foo: \"bar\"} )\r\n\r\nUnlike in some tuplespace implementations, templates are a client-side concept (except for subspace-defining templates), which is a source of efficiency and scalability. Matching operations (which can be computationally heavy) are performed on the client, rather than on the server, which would bottleneck the whole system.\r\n\r\nWhat are the operations on tuples?\r\n--------------------\r\n\r\n* read - search the space for matching tuples, waiting if none found\r\n\r\n* write - insert the tuple into the space\r\n\r\n* take - search the space for matching tuples, waiting if none found, removing the tuple if found\r\n\r\n* pulse - write and take the tuple; readers see it, but it cannot be taken by other client, and it cannot be read later (this is not a classical tuplespace operation, but is useful for publish-subscribe communication patterns)\r\n\r\nThese operations have a few variations (wait vs nowait) and options (timeouts).\r\n\r\nTransactions and optimistic concurrency\r\n--------------------\r\n\r\nTransactions combine operations into a group that take effect at the same instant in (logical) time, isolated from other transactions.\r\n\r\nHowever, it may take some time to prepare the transaction. This is true in terms of both real time (clock and process) and logical time (global sequence of operations). Preparing a transaction means finding tuples that match the criteria of the read and take operations. Finding tuples may require searching (locally) for tuples, or waiting for new tuples to be written by others. Also, the transaction may fail even after matching tuples are found (when another process takes tuples of interest). Then the transaction needs to be prepared again. Once prepared, transaction is sent to all clients, where it may either succeed (in all clients) or fail (for the same reason as before--someone else grabbed one of our tuples). If it fails, then the preparation begins again. A transaction guarantees that, when it completes, all the operations were performed on the tuples at the same logical time. It does not guarantee that the world stands still while one process is inside the `transaction {...}` block.\r\n\r\nTransactions are not just about batching up operations into a more efficient package (though you can do that with the #batch api). A transaction makes the combined operations execute atomically: the transaction finishes only when all of its operations can be successfully performed. Writes and pulses can always succeed, but takes and reads only succeed if the tuples exist.\r\n\r\nTransactions give you a means of optimistic locking: the transaction proceeds in a way that depends on preconditions. See [example/increment.rb](example/increment.rb) for a very simple example. Not only can you make a transaction depend on the existence of a tuple, you can make the effect of the transaction a function of existing tuples (see [example/transaction-logic.rb](example/transaction-logic.rb) and [example/broker-optimistic.rb](example/broker-optimistic.rb)).\r\n\r\nIf you prefer classical tuplespace locking, you can simply use certain tuples as locks, using take/write to lock/unlock them. See the examples, such as [example/broker-locking.rb](example/broker-locking.rb). If you have a lot of contention and want to avoid the thundering herd, see [example/lock-mgr-with-queue.rb](example/lock-mgr-with-queue.rb).\r\n\r\nIf an optimistic transaction fails (for example, it is trying to take a tuple, but the tuple has just been taken by another transaction), then the transaction block is re-executed, possibly waiting for new matches to the templates. Application code must be aware of the possible re-execution of the block. This is better explained in the examples...\r\n\r\nTransactions have a significant disadvantage compared to using take/write to lock/unlock tuples: a transaction can protect only resources that are represented in the tuplespace, whereas a lock can protect anything: a file, a device, a service, etc. This is because a transaction begins and ends within a single instant of logical (tuplespace) time, whereas a lock tuple can be taken out for an arbitrary duration of real (and logical) time. Furthermore, the instant of logical time in which a transaction takes effect may occur at different wall-clock times on different processes, even on the same host.\r\n\r\nTransactions do have an advantage over using take/write to lock/unlock tuples: there is no possibility of deadlock. See [example/deadlock.rb](example/deadlock.rb) and [example/parallel.rb](example/parallel.rb).\r\n\r\nAnother advantage of tranactions is that it is possible to guarantee continuous existence of a time-series of tuples. For example, suppose that tuples matching `{step: Numeric}` indicate the progress of some activity. With transactions, you can guarantee that there is exactly one matching tuple at any time, and that no client ever sees in intermediate or inconsistent state of the counter:\r\n\r\n    transaction do\r\n      step = take(step: nil)[\"step\"]\r\n      write step: step + 1\r\n    end\r\n\r\nAny client which reads this template will find a (unique) match without blocking.\r\n\r\nAnother use of transactions: forcing a retry when something changes:\r\n\r\n    transaction do\r\n      step = read(step: nil)[\"step\"]\r\n      take value: nil, step: step\r\n    end\r\n\r\nThis code waits on the existence of a value, but retries if the step changes while waiting. See example/pregel/distributed.rb for a use of this techinique.\r\n\r\nTupelo transactions are ACID in the following sense. They are Atomic and Isolated -- this is enforced by the transaction processing in each client. Consistency is enforced by the underlying message sequencer: each client's copy of the space is the deterministic result of the same sequence of operations. This is also known as [sequential consistency] (https://en.wikipedia.org/wiki/Sequential_consistency). Durability is optional, but can be provided by the persistent archiver or other clients.\r\n\r\nOn the CAP spectrum, tupelo tends towards consistency: for all clients, write and take operations are applied in the same order, so the state of the entire system up through a given tick of discrete time is universally agreed upon. This is known as [state machine replication] (http://en.wikipedia.org/wiki/State%20machine%20replication). Of course, because of the difficulties of distributed systems, one client may not yet have seen the same range of ticks as another. Tupelo's replication model (especially in the use of subspaces) can also be described as [virtual synchrony](https://en.wikipedia.org/wiki/Virtual_synchrony).\r\n\r\nTupelo transactions do not require two-phase commit, because they are less powerful than general transactions. Each client has enough information to decide (in the same way as all other clients) whether the transaction succeeds or fails. This has performance advantages, but imposes some limitations on transactions over subspaces that are known to one client but not another. [Subspaces](doc/subspace.md).\r\n\r\n\r\nSyntax\r\n======\r\n\r\nYou can use tupelo with a simplified syntax, like a \"domain-specific language\". Each construct with a block can be used in either of two forms, with an explicit block param or without. Compare [example/add-dsl.rb](example/add-dsl.rb) and [example/add.rb](example/add.rb).\r\n\r\n\r\nAdvantages\r\n==========\r\n\r\nTupelo can be used to impose a unified transactional structure and distributed access model on a mixture of programs and stores. (\"Polyglot persistence\".) Need examples....\r\n\r\nSpeed (latency, throughput):\r\n\r\n* minimal system-wide bottlenecks\r\n\r\n* non-blocking socket reads\r\n\r\n* read -- local and hence very fast\r\n\r\n* write -- fast, pipelined (waiting for acknowledgement is optional);  \r\n\r\n* transactions -- combine several takes and writes, reducing latency and avoiding locking\r\n\r\nCan use optimal data structure for each subspace of tuplespace.\r\n\r\nDecouples storage from query. (E.g. archiver for storage, optimized for just insert, delete, dump. And in-memory data structure, such as red-black tree, optimized for sorted query.)\r\n\r\nEach client can have its own matching agorithms and api -- matching is not part of the comm protocol, which is defined purely in terms of tuples.\r\n\r\nData replication is easy--hard to avoid in fact.\r\n\r\nLimitations\r\n===========\r\n\r\nBetter for small messages, because they tend to propagate widely.\r\n\r\nMay stress network and local memory (but subspaces can help).\r\n\r\nWorker thread has cpu cost (but subspaces can help).\r\n\r\nWhat other potential problems and how does tupelo solve them?\r\n\r\n\r\nFuture\r\n======\r\n\r\n- Subspaces. Redundancy, for read-heavy data stores (redundant array of in-memory sqlite, for example). Clients managing different subspaces may benefit by using different stores and algorithms.\r\n\r\n- More persistence options.\r\n\r\n- Fail-over. Robustness.\r\n\r\n- Investigate nio4r for faster networking, especially with many clients.\r\n\r\n- Interoperable client and server implementations in C, Python, Go, .... Elixir?\r\n\r\n- UDP multicast to further reduce the bottleneck in the message sequencer.\r\n\r\n- Tupelo as a service; specialized and replicated subspace managers as services.\r\n\r\n\r\nComparisons\r\n===========\r\n\r\nRedis\r\n-----\r\n\r\nUnlike redis, computations are not a centralized bottleneck. Set intersection, for example.\r\n\r\nPushing data to client eliminates need for polling, makes reads faster.\r\n\r\nTupelo's pulse/read ops are like pubsub in redis.\r\n\r\nHowever, tupelo is not a substitute for the caching functionality of redis and memcache.\r\n\r\n\r\nRinda\r\n-----\r\n\r\nVery similar api.\r\n\r\nRinda has a severe bottleneck, though: all matching, waiting, etc. are performed in one process.\r\n\r\nRinda is rpc-based, which is slower and also more vulnerable due to the extra client-server state; tupelo is imlemented on a message layer, rather than rpc. This also helps with pipelined writes.\r\n\r\nTupelo also supports custom classes in tuples, but only with marshal / yaml; must define #==; see [example/custom-class.rb](example/custom-class.rb)\r\n\r\nBoth: tuples can be arrays or hashes.\r\n\r\nSpaces have an advantage over distributed hash tables: different clients may acccess tuples in terms of different dimensions. For example, a producer generates [producer_id, value]; a consumer looks for [nil, SomeParticularValues]. Separation of concerns, decoupling in the data space.\r\n\r\n\r\nTo compare\r\n----------\r\n\r\n* beanstalkd\r\n\r\n* resque\r\n\r\n* zookeeper -- totally ordered updates; tupelo trades availability for lower latency (?)\r\n\r\n* chubby\r\n\r\n* doozer, etcd\r\n\r\n* serf -- tupelo has lower latency and is transactional, but at a cost compared to serf; tupelo semantics is closer to databases\r\n\r\n* arakoon\r\n\r\n* hazelcast\r\n\r\n* lmax -- minimal spof\r\n\r\n* datomic -- similar distribution of \"facts\", but not tuplespace; similar use of pluggable storage managers\r\n\r\n* job queues: sidekiq, resque, delayedjob, http://queues.io, https://github.com/factual/skuld\r\n\r\n* pubsubs: kafka\r\n\r\n* spark, storm\r\n\r\n* tibco and gigaspace\r\n\r\n* gridgain\r\n\r\n\r\nArchitecture\r\n============\r\n\r\nTwo central processes:\r\n\r\n* message sequencer -- assigns unique increasing IDs to each message (a message is essentially a transaction containing operations on the tuplespace). This is the key to the whole design. By sequencing all transactions in a way that all clients agree with, the transactions can be applied (or rejected) by all clients without further negotiation.\r\n\r\n* client sequencer -- assigns unique increasing IDs to clients when they join the distributed system\r\n\r\nSpecialized clients:\r\n\r\n* archiver -- dumps tuplespace state to clients joining the system later than t=0; at least one archiver is required, unless all clients start at t=0.\r\n\r\n* tup -- command line shell for accessing (and creating) tuplespaces\r\n\r\n* tspy -- uses the notification API to watch all events in the space\r\n\r\n* queue / lock / lease managers (see examples)\r\n\r\nGeneral application clients:\r\n\r\n* contain a worker thread and any number of application-level client threads\r\n\r\n* worker thread manages local tuplespace state and requests to modify or access it\r\n\r\n* client threads construct transactions and wait for results (communicating with the worker thread over queues); they may also use asynchronous transactions\r\n\r\nSome design principles:\r\n\r\n* Once a transaction has been sent from a client to the message sequencer, it references only tuples, not templates. This makes it faster and simpler for each receiving client to apply or reject the transaction. Also, clients that do not support local template searching (such as archivers) can store tuples using especially efficient data structures that only support tuple-insert, tuple-delete, and iterate/export operations.\r\n\r\n* Use non-blocking protocols. For example, transactions can be evaluated in one client without waiting for information from other clients. Even at the level of reading messages over sockets, tupelo uses (via funl and object-stream) non-blocking constructs. At the application level, you can use transactions to optimistically modify shared state (but applications are free to use locking if high contention demands it).\r\n\r\n* Do the hard work on the client side. For example, all pattern matching happens in the client that requested an operation that has a template argument, not on the server or other clients.\r\n\r\nProtocol\r\n--------\r\n\r\nNothing in the protocol specifies local searching or storage, or matching, or notification, or templating. That's all up to each client. The protocol only contains tuples and operations on them (take, write, pulse, read), combined into transactions.\r\n\r\nThe protocol has two layers. The outer (message) layer is 6 fields, managed by the funl gem, using msgpack for serialization. All socket reads are non-blocking (using msgpack's stream mode), so a slow sender will not block other activity in the system.\r\n\r\nOne of those 6 fields is a data blob, containing the actual transaction and tuple information. The inner (blob) layer manages that field using msgpack (by default), marshal, json, or yaml. This layer contains the transaction operations. The blob is not unpacked by the server, only by clients.\r\n\r\nEach inner serialization method (\"blobber\") has its own advantages and drawbacks:\r\n\r\n* marshal is ruby only, but can contain the widest variation of objects\r\n\r\n* yaml is portable and humanly readable, and still fairly diverse, but very inefficient\r\n\r\n* msgpack and json (yajl) are both relatively efficient (in terms of packet size, as well as parse/emit time)\r\n\r\n* msgpack and json support the least diversity of objects (just \"JSON objects\"), but msgpack also supports hash keys that are objects rather than just strings.\r\n\r\nFor most purposes, msgpack is a good choice, so it is the default.\r\n\r\nThe sending client's tupelo library must make sure that there is no aliasing within the list of tuples (this is only an issue for Marshal and YAML, since msgpack and json do not support references).\r\n\r\n\r\nDevelopment\r\n===========\r\n\r\nPatches and bug reports are most welcome.\r\n\r\nThis project is hosted at\r\n\r\nhttps://github.com/vjoel/tupelo\r\n\r\nDependencies\r\n------------\r\n\r\nGems that were developed to support this project:\r\n\r\n* https://github.com/vjoel/atdo\r\n\r\n* https://github.com/vjoel/easy-serve\r\n\r\n* https://github.com/vjoel/funl\r\n\r\n* https://github.com/vjoel/object-stream\r\n\r\n* https://github.com/vjoel/object-template\r\n\r\nOther gems:\r\n\r\n* msgpack\r\n\r\n* yajl-ruby (only used to support --json option)\r\n\r\nOptional gems for some of the examples:\r\n\r\n* sinatra, http, sequel, sqlite, rbtree, leveldb-native\r\n\r\nContact\r\n=======\r\n\r\nJoel VanderWerf, vjoel@users.sourceforge.net, @JoelVanderWerf.\r\n\r\nLicense and Copyright\r\n========\r\n\r\nCopyright (c) 2013, Joel VanderWerf\r\n\r\nLicense for this project is BSD. See the COPYING file for the standard BSD license. The supporting gems developed for this project are similarly licensed.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}