#!/usr/bin/env ruby

if ARGV.delete("-h") or ARGV.delete("--help")
  puts <<-END
    Usage:
      #$0

      #$0 servers_file
      #$0 servers_file <script...

      #$0 servers_file unix [path]
      #$0 servers_file tcp [host [port]]]
    
    The first form starts a tuplespace server as a child process. Then it
    enters an interactive session in which the current object is the proxy to
    that tuplespace. This form is useful for an isolated tuplespace for
    simple experiments.
    
    The second form tries to open the servers_file. If it cannot, then as in the
    first form, it starts a tuplespace server child process and writes its
    address to servers_file. If it can open the servers_file, then it simply
    connects to the referenced tuplespace server. In either case, as in the
    first form, an interactive session starts. This form (in its two variants)
    is useful for starting two sessions operating on the same tuplespace.

    The third form is like the second form, but executes the input instead of
    starting an interactive session. Output is like irb output, with input lines
    alternating with their output. This is useful for generating human-readable
    transcripts.

    The fourth and fifth forms are like the previous, but can be used to expose
    the server on more or less public sockets with specified addresses. In the
    tcp case, the servers_file can be copied to other hosts and used with tup
    to connect to the servers (adjust the host references as needed). The
    default for unix is, as in the first three forms, a path in a tmpdir. The
    default for tcp is localhost with port 0, and hence a dynamically chosen
    port. These forms are only for starting a new server; connecting to an
    existing server uses the simpler form "#$0 servers_file".

    Options:
    
      --debug     set the log level
      --info
      --warn      <-- default
      --error
      --fatal
      
      -v          verbose mode (include time and pid in log messages)
      
      --trace     enable trace output
      
      --pubsub    publish/subscribe mode; does not keep local tuple store:
      
                    * read only works in blocking mode (waiting for new tuple)
                    * write and pulse work normally
                    * take does not work

      --marshal   use specified library to serialize objects
      --yaml
      --json
      --msgpack   <-- default
      
      --persist-dir DIR
                  load and save tuplespace to DIR

  END
  exit
end

require 'tupelo/app'

argv, tupelo_opts = Tupelo.parse_args(ARGV)

pubsub = argv.delete("--pubsub") # not a standard tupelo opt

servers_file = argv.shift
addr = argv.shift(3)

Tupelo.application(
  argv: argv,
  **tupelo_opts,
  servers_file: servers_file,
  seqd_addr: addr,
  cseqd_addr: addr, # using same addr causes autoincrement of port/filename
  arcd_addr: addr) do

  class TupClient < Tupelo::Client
    alias w write_wait
    alias pl pulse_wait
    alias t take
    alias r read_wait
    alias ra read_all
    alias tr transaction
    CMD_ALIASES = %w{ w pl t r ra tr }
    private *CMD_ALIASES
  end

  client_opts = {}
  if pubsub
    client_opts[:arc] = nil
    client_opts[:tuplespace] = TupClient::NullTuplespace
  end

  local TupClient, **client_opts do
    log.info {"cpu time: %.2fs" % Process.times.inject {|s,x|s+x}}
    log.info {"starting shell. Commands: #{TupClient::CMD_ALIASES.join(", ")}"}

    require 'tupelo/app/irb-shell'
    IRB.start_session(self)
  end
end
